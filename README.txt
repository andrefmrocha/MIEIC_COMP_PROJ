# Javamm Compiler
### GROUP:  g5f

* Ana Margarida Ruivo Loureiro, 201705749, GRADE: 20, CONTRIBUTION: 25%
* André Filipe Magalhães Rocha, 201706462, GRADE: 20, CONTRIBUTION: 25%
* João Miguel Ribeiro de Castro Silva Martins , 201707311, GRADE: 20, CONTRIBUTION: 25%
* Mário Gil Marinho Mesquita, 201705723, GRADE: 20, CONTRIBUTION: 25%

**GLOBAL GRADE OF THE PROJECT**: 20

## SUMMARY

A compiler of Java-- programs to Java bytecodes.

## EXECUTE 

For this project, you need to [install Gradle](https://gradle.org/install/)

Copy your ``.jjt`` file to the ``javacc`` folder. If you change any of the classes generated by ``jjtree`` or ``javacc``, you also need to copy them to the ``javacc`` folder.

Copy your source files to the ``src`` folder, and your JUnit test files to the ``test`` folder.

### Compile

To compile the program, run ``gradle build``. This will compile your classes to ``classes/main/java`` and copy the JAR file to the root directory. The JAR file will have the same name as the repository folder.

#### Run

To run you have two options: Run the ``.class`` files or run the JAR.

#### Run ``.class``

To run the ``.class`` files, do the following:

```cmd
java -cp "./build/classes/java/main/" <class_name> <arguments>
```

Where ``<class_name>`` is the name of the class you want to run and ``<arguments>`` are the arguments to be passed to ``main()``.

#### Run ``.jar``

To run the JAR, do the following command:

```cmd
java -jar <jar filename> [-d] [-o] [-r] <arguments>
```

Where ``<jar filename>`` is the name of the JAR file that has been copied to the root folder, `` -d `` is the debug mode flag, `` -o `` is the optmization mode flag related to loops and variables,  `` -r `` is the register allocation optimization mode flag and ``<arguments>`` are the arguments to be passed to ``main()``.

#### Test

To test the program, run ``gradle test``. This will execute the build, and run the JUnit tests in the ``test`` folder. If you want to see output printed during the tests, use the flag ``-i`` (i.e., ``gradle test -i``).


## DEALING WITH SYNTACTIC ERRORS

In this project, the syntactic errors addressed are relative to loops. The compiler reports at most 10 errors before aborting the execution. 
At each error caught a message will be displayed. It will contain information about the line and column of the occurrence as well as the token found and the one expected. 
Besides, some tokens must be skipped to continue with the syntactic analysis. Thus, it will also be displayed in a message the tokens skipped to continue with the normal execution of the analysis.

## SEMANTIC ANALYSIS
 
There is a general approach to semantic analysis. Each AST node has an **eval** function to process the semantic analysis. If the semantic checks fail a semantic exception will be thrown with an appropriate message. 
A check that happens in many nodes is related to the correct **number of children** nodes as well as the **types** expected. 

All the **variables** have a series of checks to make sure their declaration is correctly built; the identifier is valid; it hasn't been previously defined in the scope.

Furthermore the analysis of the **matching of the nodes types** is ensured. Those situations occur when assigning variables, accessing variables, the return type of methods, and, negation, comparisons, and arithmetic expressions. 

The **import** statements analysis consists in the division of the import statements in class declarations, respective functions, and static import statements and checks if the functions declared are associated with a class declaration;

The **methods** are processed in two steps so that we can ensure methods that are called before being declared. This division allows us to first collect information on all the methods so that when those are called in the body of the method an exception won't be thrown.

The **conditional expression** - *if-else* - checks if any variable is only initialized in one of the branches - *then* or *else* - when it should be initialized in both; the failure will throw a warning.

The **extension** of classes is also ensured in this semantic analysis. To do so we need to verify if the extended class already exists. This is done by checking the parent symbol table.


## INTERMEDIATE REPRESENTATION

For the intermediate representations (IRs), our tool uses an  **Abstract Syntactic Tree (AST)** for the High-Level Intermediate Representation (HLIR).  The AST is successful in representing the expressions’ precedences in the proposed grammar. This enables us to preserve the correct operation order based on the **rules of priority** we implemented in the AST.  This way the representation allows us to have a structure that facilitates a correct semantic analysis and the code generation phase. 

Furthermore, we implemented **Symbol tables** when doing the semantic analysis and were structured in these categories: 
* **Import Table:** includes the information related to the imported static methods, classes and imported methods
* **Class Table:** includes the information of the name, attributes or variables present in the main function and the class methods
*  **Method Table:** includes the *header* and the variables declared in its scope

It is also important to explain the representation of the variables and methods in these structures:  

 * **Variable Information:** used to represent classes in the import table and class attributes and variables in the class table; information about the name and its type
* **Method Information:** Used in the class and method table (*header*); information about the name, parameters and return type 

There were two different **scopes** were the symbol tables were implemented: 
* the import and classes 
* the methods

For easier access necessary in the semantic analysis, the symbol tables classes created have the **parent** symbol table associated.

## CODE GENERATION
During the semantic analysis of the code, the different nodes are annotated with some lower-level information, much relevant to the code generation step.

This is a common method for several different steps, such as the use of variable identifiers. Whenever the identifier of a variable is found, it is obtained the symbol existing regarding it. This symbol is annotated with immense information that describes the symbol:
 - if it can be substituted by a constant
 - what register it is allocated to
 - what sort of variable it stores, and how to characterize the JVM type and prefix

This sort of approach is repeated in all nodes that need information being stored beforehand.

One of the problems that is easily identified is that the structure of the code generation may not easily make new optimizations, which makes it much harder to implement new ones.

## OVERVIEW
The AST tree created is traversed two different times, in order to first annotate it with different important information, then another one to generate the actual code. It is important to notice how some steps may actually traverse it more times, such as the **body of a method**. 

To properly obtain information regarding the flow of data, it was used the algorithm presented in the known [Tiger Book](https://www.cs.princeton.edu/~appel/modern/) for dataflow analysis. This gave us a way to describe the life of a variable, with their respective Live-in and Live-out.
This allowed us to create a register allocation algorithm based on **vertex coloring**, which allows for the use of a minimal number of registers.
This was also the means to create the *dead-code* optimization.

No external libraries, but the required ones of **jasmin and javacc** were used.

## TASK DISTRIBUTION

- Ambiguity Analysis - André Rocha, Ana Loureiro
- Declarations - João Martins
- Parser
	- Import Declarations - Mário Gil
	- Expression - André Rocha
	- Statement - João Martins 
	- Declarations - Ana Loureiro
	- Import - Ana Loureiro
- Error treatment and Recovery mechanisms - Mário Gil
- Eliminate Lookahead - André Rocha **[Checkpoint1]**
- Symbol Tables
  - Generic Implementation - André Rocha
  - Classes, Class fields and Methods - Ana Loureiro
  - Import - Mário Gil
  - Local variables and Parameters - João Martins  
 - Semantic 
	 - If, while, Return - João Martins
	 - Negation, And, Less Than, Parameters - João Martins, André Rocha 
	 - Assign variables and arrays , Import - Mário Gil
	 - Class and Method - Ana Loureiro
	 - Logging errors - André Rocha
	 - Extra: Class constructor with arguments - André Rocha
	 - Debug mode "-d" - João Martins 
- Code generation
   - Basic structure of declaration class, fields and methods - André Rocha
   -  Generic Function Setup, Arithmetic Expressions, Conditional Instructions - João Martins 
   -  Call Expressions, Loops - Ana Loureiro
   - Assignments, Arrays - Mário Gil **[Checkpoint2]**
 - Example Tests - Ana Loureiro, João Martins 
 - Locals and Stack Limits - Mário Gil, André Rocha **[Checkpoint 3]**
- `-R` optimization - André Rocha, Mário Gil
- `-O` optimization - Ana Loureiro, João Martins 
- Optimization - conditions with 0 - João Martins
- Optimization  - Dead code elimination: delete unused stores - João Martins
- Code Documentation - André Rocha e Mário Gil 
- Readme - Ana Loureiro e André Rocha **[Final Delivery]**

## PROS

All the requirements were accomplished including all the optimization modes.
Additionally, more features were added or perfected such as:
* Debug mode with a better understanding of the tree representation as well as the symbol tables
* Possible to have a constructor with parameters
* Possible to have void functions
* Detection of uninitialized variables (including in all the conditional branches)
* Optimization in the numeric variables in the code generation instructions based on its size
* Extra optimization: delete unused stores and give a warning about unreachable code after the return

## CONS
Due to time constrictions, the code has significant technical debt, making it harder to add new features as of right now. It would require some refactoring to make it more reasonable to add new features.
