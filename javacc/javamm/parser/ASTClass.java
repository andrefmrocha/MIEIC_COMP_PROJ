package javamm.parser;

import javamm.SemanticsException;
import javamm.semantics.*;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/* Generated By:JJTree: Do not edit this line. ASTClass.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_Javamm=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTClass extends SimpleNode {
  public ClassSymbol classSymbol;

  public ASTClass(int id) {
    super(id);
  }

  public ASTClass(Javamm p, int id) {
    super(p, id);
  }

  @Override
  public void eval(Javamm parser) {
    final MethodSymbolTable newTable = new MethodSymbolTable(methodTable);
    final SymbolTable symbolTable = new SymbolTable(table);
    this.table = symbolTable;
    String className = null;
    ClassSymbol extendedClass = null;

    for (int i = 0; i < this.jjtGetNumChildren(); i++) {
      SimpleNode child = (SimpleNode) this.jjtGetChild(i);

      switch (child.id) {
        case JavammTreeConstants.JJTVAR:
          child.setTables(table, newTable);
          child.eval(parser);
          break;
        case JavammTreeConstants.JJTEXTEND:
          child.setTables(table, newTable);
          child.eval(parser);
          extendedClass = ((ASTExtend) child).extendedClass;
          classSymbol = new ClassSymbol(Symbol.Type.CLASS, className, newTable, extendedClass);
          table.putSymbol(className, classSymbol);
          break;
        case JavammTreeConstants.JJTIDENTIFIER:
          ASTIdentifier temp = (ASTIdentifier) child;
          className = temp.identifierName;
          this.table.setClassName(className);
          classSymbol = new ClassSymbol(Symbol.Type.CLASS, className, newTable, extendedClass);
          table.putSymbol(className, classSymbol);
          break;
        case JavammTreeConstants.JJTMETHOD:
          child.setTables(new SymbolTable(table), newTable);
          child.eval(parser);
          break;
        default:
          parser.semanticErrors.add(new SemanticsException("Incorrect child node", child));
          return;
      }
    }

    for (int i = 0; i < this.jjtGetNumChildren(); i++) {
      SimpleNode child = (SimpleNode) this.jjtGetChild(i);
      if (child.id == JavammTreeConstants.JJTMETHOD) {
        ASTMethod method = (ASTMethod) child;
        for (Symbol symbol : method.getParameters())
          symbol.setStackPos(symbol.getStackPos() + 1);
        method.processBody(parser, method.getParameters().size() +  1);
      }
    }
  }


  @Override
  public void write(PrintWriter writer) {
    writer.println(".class public " + classSymbol.getClassName());
    writer.println(".super " + (classSymbol.getExtension() == null ? "java/lang/Object" : classSymbol.getExtension().getClassName()));
    writer.println();

    int i = 1;
    for (; i < this.jjtGetNumChildren(); i++) {
      SimpleNode child = (SimpleNode) this.jjtGetChild(i);
      if (child.id == JavammTreeConstants.JJTVAR)
        child.write(writer);
      else
        break;
    }
    if (i != 1)
      writer.println();

    writer.println(".method public <init>()V\n" +
        "  aload_0\n" +
        "  invokenonvirtual java/lang/Object/<init>()V\n" +
        "  return\n" +
        ".end method\n");

    for (; i < this.jjtGetNumChildren(); i++) {
      SimpleNode child = (SimpleNode) this.jjtGetChild(i);
      if (child.id == JavammTreeConstants.JJTMETHOD)
        child.write(writer);
    }
  }

  @Override
  public void printTable() {
    System.out.println("//".repeat(40));
    System.out.println("Class Table:");

    System.out.println("    Name: " + classSymbol.getClassName() +
        (classSymbol.getExtension() == null ? "\n" : " | Extends: " + classSymbol.getExtension().getClassName() + "\n"));

    if (!this.table.getTable().isEmpty()) {
      System.out.println("    Variable Table:");
      Iterator it = this.table.getTable().entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry pair = (Map.Entry) it.next();
        System.out.println("      Name: " + pair.getKey() + " | Type: " + ((Symbol) pair.getValue()).getType());
      }
      System.out.println();
    }

    MethodSymbolTable classMeth = classSymbol.getMethods();
    if (!classMeth.getTable().isEmpty()) {
      System.out.println("    Class Methods:");
      Iterator it = classMeth.getTable().entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry pair = (Map.Entry) it.next();
        System.out.print("      Name: " + ((MethodIdentifier) pair.getKey()).getIdentifier() + " | Params: <");
        List<Symbol.Type> parameters = ((MethodSymbol)pair.getValue()).getParameters();
        for(int i = 0 ; i < parameters.size(); i++) {
          System.out.print(parameters.get(i));
          if(i != parameters.size()-1)
            System.out.print(",");
          else
            break;
        }
        System.out.println("> | Returns: " + ((MethodSymbol) pair.getValue()).getReturnSymbol().getType());
      }
      System.out.println();
    }

    super.printTable();
  }
}
/* JavaCC - OriginalChecksum=f92e5600b4d1b54c8cf65f0fa9dc9373 (do not edit this line) */
