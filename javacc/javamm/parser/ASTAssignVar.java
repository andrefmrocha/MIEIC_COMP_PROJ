package javamm.parser;

import javamm.SemanticsException;
import javamm.cfg.CFGNode;
import javamm.cfg.CFGSymbol;
import javamm.semantics.StackUsage;
import javamm.semantics.Symbol;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/* Generated By:JJTree: Do not edit this line. ASTAssignVar.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_Javamm=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTAssignVar extends TypeNode {
    public String varIdentifier;
    private int iinc = Integer.MAX_VALUE;
    private CFGNode assignNode = null;
    private boolean usedSymbol;
    private Symbol leftSymbol;

    public ASTAssignVar(int id) {
        super(id);
        this.validStatement = true;
    }

    public ASTAssignVar(Javamm p, int id) {
        super(p, id);
        this.validStatement = true;
    }

    @Override
    public void eval(Javamm parser) {
        if (this.jjtGetNumChildren() != 2) {
            parser.semanticErrors.add(new SemanticsException("Variable assignment must have two operators", this));
            return;
        }

        SimpleNode identifier = (SimpleNode) this.jjtGetChild(0);

        if (identifier.id != JavammTreeConstants.JJTIDENTIFIER) {
            parser.semanticErrors.add(new SemanticsException("Variable has not a valid identifier", identifier));
            return;
        }

        ASTIdentifier temp = (ASTIdentifier) identifier;
        varIdentifier = temp.identifierName;

        if (!this.table.checkSymbol(varIdentifier)) {
            parser.semanticErrors.add(new SemanticsException("Variable " + varIdentifier + " does not exist", identifier));
            return;
        }

        leftSymbol = this.table.getSymbol(varIdentifier);

        SimpleNode expression = (SimpleNode) this.jjtGetChild(1);
        this.evaluateChild(expression, leftSymbol, parser);

        if (!leftSymbol.isInitialized())
            leftSymbol.setInitialized();

        if (!leftSymbol.hasChanged() && !checkConstant(expression, leftSymbol)) {
            leftSymbol.didChange();
        }

        if (expression.id == JavammTreeConstants.JJTSUM && leftSymbol.getStackPos() != -1)
            this.optimizeMathOperation(expression);
    }

    public boolean checkConstant(SimpleNode node, Symbol symbol) {
        switch (node.id) {
            case JavammTreeConstants.JJTNUMERIC:
                symbol.setValue(((ASTNumeric) node).number);
                return true;
            case JavammTreeConstants.JJTBOOLEANVALUE:
                symbol.setValue(((ASTBooleanValue) node).bool ? 1 : 0);
                return true;
            default:
                //the node is not a constant value
                return false;
        }
    }

    public void optimizeMathOperation(SimpleNode expression) {
        List<SimpleNode> nodes = getSumNodes((ASTSum) expression);
        boolean hasOnlyConstants = true;
        boolean hasSelfIdentifier = false;
        int counter = 0;
        for (SimpleNode node : nodes) {
            if (node.id == JavammTreeConstants.JJTIDENTIFIER) {
                final ASTIdentifier sumIdentifier = (ASTIdentifier) node;
                if (sumIdentifier.identifierName.equals(varIdentifier)) {
                    if (hasSelfIdentifier) {
                        hasSelfIdentifier = false;
                        break;
                    } else
                        hasSelfIdentifier = true;
                } else {
                    hasOnlyConstants = false;
                    break;
                }
            } else if (node.id == JavammTreeConstants.JJTNUMERIC) {
                final ASTNumeric numeric = (ASTNumeric) node;
                counter += numeric.number;
            } else {
                hasOnlyConstants = false;
                break;
            }
        }

        if (hasOnlyConstants && hasSelfIdentifier)
            iinc = counter;

    }

    public List<SimpleNode> getSumNodes(ASTSum sum) {
        final List<SimpleNode> nodes = new ArrayList<>();
        for (int i = 0; i < sum.jjtGetNumChildren(); i++) {
            final SimpleNode node = (SimpleNode) sum.jjtGetChild(i);
            if (node.id == JavammTreeConstants.JJTSUM) {
                nodes.addAll(getSumNodes((ASTSum) node));
            } else {
                nodes.add(node);
            }
        }

        return nodes;
    }

    @Override
    public void write(PrintWriter writer) {

        String varName = ((ASTIdentifier) this.jjtGetChild(0)).identifierName;
        Symbol leftSymbol = this.table.getSymbol(varName);
        int varNum = leftSymbol.getStackPos();
        SimpleNode right = (SimpleNode) this.jjtGetChild(1);

        if (iinc != Integer.MAX_VALUE && iinc >= -32768 && iinc <= 32767) {
            final String iincInstruction = (iinc > 127 || iinc < -128) ? "iinc_w" : "iinc";
            writer.println("  " + iincInstruction + " " + varNum + " " + iinc);
        }
        //if optimizing, check if the value of the assignment is used before another assignment or the variable is constant
        else if (isStorable(leftSymbol, varNum, usedSymbol)) {
            if (varNum == -1)
                writer.println("  aload_0");
            // result will be on stack
            right.write(writer);

            if (varNum == -1) {
                String className = this.table.getClassName();
                String jvmType = leftSymbol.getJVMType();
                writer.println("  putfield " + className + "/" + varName + " " + jvmType + "\n");
            } else {
                String storeInstr = Symbol.getJVMPrefix(leftSymbol.getType()) + "store";
                String separator = varNum > 3 ? " " : "_";
                writer.println("  " + storeInstr + separator + Integer.toString(varNum) + "\n");
            }
        }
    }

    public void isUsedSymbol() {
        usedSymbol = false;
        if(leftSymbol.getStackPos() != -1) {
            usedSymbol = findSymbolUse(assignNode.getEdges(),new CFGSymbol(varIdentifier, leftSymbol));
            assignNode.resetVisited();
        }

        if(isStorable(leftSymbol, leftSymbol.getStackPos(), usedSymbol))
            leftSymbol.didChange();
    }

    private boolean isStorable(Symbol leftSymbol, int varNum, boolean usedSymbol) {
        return varNum == -1 || !ASTProgram.optimize || (usedSymbol && (leftSymbol.hasChanged() || leftSymbol.getValue() == -1));
    }

    protected boolean findSymbolUse(List<CFGNode> edges, CFGSymbol symbol) {
        for(CFGNode cfgNode : edges) {
            if(cfgNode.getEdges().size() > 1){
                symbol.getSymbol().didChange();
                return true;
            }

            if(cfgNode.visited || cfgNode.getDefinedVars().contains(symbol)) continue;
            cfgNode.visited = true;
            if (cfgNode.getOut().contains(symbol) || cfgNode.getUsedVars().contains(symbol) || findSymbolUse(cfgNode.getEdges(), symbol)) return true;
        }
        return assignNode.getOut().contains(symbol);
    }

    @Override
    protected void calculateStackUsage(StackUsage stackUsage) {
        if (iinc != Integer.MAX_VALUE && iinc >= -32768 && iinc <= 32767) return;

        String varName = ((ASTIdentifier) this.jjtGetChild(0)).identifierName;
        Symbol leftSymbol = this.table.getSymbol(varName);
        int varNum = leftSymbol.getStackPos();
        SimpleNode right = (SimpleNode) this.jjtGetChild(1);

        if (varNum == -1)
            stackUsage.inc(1);

        right.calculateStackUsage(stackUsage);

        stackUsage.dec(varNum == -1 ? 2 : 1);
    }

    @Override
    public List<CFGNode> getNodes() {
        List<CFGNode> nodes = new ArrayList<>();
        ASTIdentifier identifier = (ASTIdentifier) this.jjtGetChild(0);
        List<CFGSymbol> used = ((SimpleNode) this.jjtGetChild(1)).getSymbols();
        if (table.checkSymbol(identifier.identifierName)) {
            final Symbol symbol = table.getSymbol(identifier.identifierName);
            if (symbol.getStackPos() == -1) {
                return Collections.singletonList(new CFGNode(used));
            }
            this.assignNode = new CFGNode(used,
                Collections.singletonList(new CFGSymbol(identifier.identifierName, symbol)));
            nodes.add(this.assignNode);
        }
        return nodes;
    }
}

/* JavaCC - OriginalChecksum=661756e145ed220ec46575b3a8adecd3 (do not edit this line) */
