package javamm.parser;

import javamm.SemanticsException;
import javamm.cfg.CFGNode;
import javamm.cfg.CFGSymbol;
import javamm.semantics.StackUsage;
import javamm.semantics.Symbol;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/* Generated By:JJTree: Do not edit this line. ASTAssignVar.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_Javamm=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTAssignVar extends TypeNode {
    public String varIdentifier;
    private int iinc = Integer.MAX_VALUE;
    public boolean optimized;

    public ASTAssignVar(int id) {
        super(id);
        this.validStatement = true;
        optimized = ASTProgram.optimize;
    }

    public ASTAssignVar(Javamm p, int id) {
        super(p, id);
        this.validStatement = true;
        optimized = ASTProgram.optimize;
    }

    @Override
    public void eval(Javamm parser) {
        if (this.jjtGetNumChildren() != 2) {
            parser.semanticErrors.add(new SemanticsException("Variable assignment must have two operators", this));
            return;
        }

        SimpleNode identifier = (SimpleNode) this.jjtGetChild(0);

        if (identifier.id != JavammTreeConstants.JJTIDENTIFIER) {
            parser.semanticErrors.add(new SemanticsException("Variable has not a valid identifier", identifier));
            return;
        }

        ASTIdentifier temp = (ASTIdentifier) identifier;
        varIdentifier = temp.identifierName;

        if (!this.table.checkSymbol(varIdentifier)) {
            parser.semanticErrors.add(new SemanticsException("Variable " + varIdentifier + " does not exist", identifier));
            return;
        }

        Symbol symbol = this.table.getSymbol(varIdentifier);
        if(!optimized)
            symbol.didChange();

        SimpleNode expression = (SimpleNode) this.jjtGetChild(1);
        this.evaluateChild(expression, symbol, parser);

        if (!symbol.isInitialized())
            symbol.setInitialized();

        if(!symbol.hasChanged() && !checkConstant(expression,symbol)) {
            symbol.didChange();
        }

        if (expression.id == JavammTreeConstants.JJTSUM && symbol.getStackPos() != -1)
            this.optimizeMathOperation(expression);
    }

    public boolean checkConstant(SimpleNode node, Symbol symbol) {
        switch(node.id) {
            case JavammTreeConstants.JJTNUMERIC:
                symbol.setValue(((ASTNumeric)node).number);
                return true;
            case JavammTreeConstants.JJTBOOLEANVALUE:
                symbol.setValue(((ASTBooleanValue)node).bool?1:0);
                return true;
            default:
                //the node is not a constant value
                return false;
        }
    }

    public void optimizeMathOperation(SimpleNode expression) {
        List<SimpleNode> nodes = getSumNodes((ASTSum) expression);
        boolean hasOnlyConstants = true;
        boolean hasSelfIdentifier = false;
        int counter = 0;
        for (SimpleNode node : nodes) {
            if (node.id == JavammTreeConstants.JJTIDENTIFIER) {
                final ASTIdentifier sumIdentifier = (ASTIdentifier) node;
                if (sumIdentifier.identifierName.equals(varIdentifier)) {
                    if (hasSelfIdentifier) {
                        hasSelfIdentifier = false;
                        break;
                    } else
                        hasSelfIdentifier = true;
                } else {
                    hasOnlyConstants = false;
                    break;
                }
            } else if (node.id == JavammTreeConstants.JJTNUMERIC) {
                final ASTNumeric numeric = (ASTNumeric) node;
                counter += numeric.number;
            } else {
                hasOnlyConstants = false;
                break;
            }
        }

        if (hasOnlyConstants && hasSelfIdentifier)
            iinc = counter;

    }

    public List<SimpleNode> getSumNodes(ASTSum sum) {
        final List<SimpleNode> nodes = new ArrayList<>();
        for (int i = 0; i < sum.jjtGetNumChildren(); i++) {
            final SimpleNode node = (SimpleNode) sum.jjtGetChild(i);
            if (node.id == JavammTreeConstants.JJTSUM) {
                nodes.addAll(getSumNodes((ASTSum) node));
            } else {
                nodes.add(node);
            }
        }

        return nodes;
    }

    @Override
    public void write(PrintWriter writer) {

        String varName = ((ASTIdentifier) this.jjtGetChild(0)).identifierName;
        Symbol leftSymbol = this.table.getSymbol(varName);
        int varNum = leftSymbol.getStackPos();
        SimpleNode right = (SimpleNode) this.jjtGetChild(1);
        if (iinc != Integer.MAX_VALUE && iinc >= -32768 && iinc <= 32767) {
            final String iincInstruction = (iinc > 127 || iinc < -128) ? "iinc_w" : "iinc";
            writer.println("  " + iincInstruction + " " + varNum + " " + iinc);
        } else if(!optimized || leftSymbol.hasChanged() || leftSymbol.getValue() == -1) { //the optimization is off or the variable isn't a constant
            if (varNum == -1)
                writer.println("  aload_0");
            // result will be on stack
            right.write(writer);

            if (varNum == -1) {
                String className = this.table.getClassName();
                String jvmType = leftSymbol.getJVMType();
                writer.println("  putfield " + className + "/" + varName + " " + jvmType + "\n");
            } else {
                String storeInstr = Symbol.getJVMPrefix(leftSymbol.getType()) + "store";
                String separator = varNum > 3 ? " " : "_";
                writer.println("  " + storeInstr + separator + Integer.toString(varNum) + "\n");
            }
        }
    }

    @Override
    protected void calculateStackUsage(StackUsage stackUsage) {
        if (iinc != Integer.MAX_VALUE && iinc >= -32768 && iinc <= 32767) return;

        String varName = ((ASTIdentifier) this.jjtGetChild(0)).identifierName;
        Symbol leftSymbol = this.table.getSymbol(varName);
        int varNum = leftSymbol.getStackPos();
        SimpleNode right = (SimpleNode) this.jjtGetChild(1);

        if (varNum == -1)
            stackUsage.inc(1);

        right.calculateStackUsage(stackUsage);

        stackUsage.dec(varNum == -1 ? 2 : 1);
    }

    @Override
    public List<CFGNode> getNodes() {
        List<CFGNode> nodes = new ArrayList<>();
        ASTIdentifier identifier = (ASTIdentifier) this.jjtGetChild(0);
        List<CFGSymbol> used = ((SimpleNode) this.jjtGetChild(1)).getSymbols();
        if (table.checkSymbol(identifier.identifierName)) {
            final Symbol symbol = table.getSymbol(identifier.identifierName);
            if (symbol.getStackPos() == -1){
                System.out.println("Defined variable" + identifier.identifierName + " is defined in top level");
                return Collections.singletonList(new CFGNode(used));
            }

            nodes.add(new CFGNode(used,
                    Collections.singletonList(new CFGSymbol(identifier.identifierName, symbol))));
        } else {
            System.out.println("Var " + identifier.identifierName + " not found");
        }
        return nodes;
    }
}

/* JavaCC - OriginalChecksum=661756e145ed220ec46575b3a8adecd3 (do not edit this line) */
