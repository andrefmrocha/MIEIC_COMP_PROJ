package javamm.parser;

import javamm.SemanticsException;
import javamm.semantics.Symbol;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

/* Generated By:JJTree: Do not edit this line. ASTMethod.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_Javamm=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTMethod extends TypeNode {
    public List<Symbol> parameters = new ArrayList<>();
    public ASTMethod(int id) {
        super(id);
    }

    public ASTMethod(Javamm p, int id) {
        super(p, id);
    }

    @Override
    public void eval(Javamm parser) {
        if (this.jjtGetNumChildren() != 2 && this.jjtGetNumChildren() != 3){
            parser.semanticErrors.add(new SemanticsException("Lacks the number of required children!", this));
            return;
        }
        SimpleNode methodType = (SimpleNode) this.jjtGetChild(0);
        SimpleNode parameters;

        if (this.jjtGetNumChildren() == 2) {
            parameters = null;
        } else {
            parameters = (SimpleNode) this.jjtGetChild(1);
        }

        if (methodType.id == JavammTreeConstants.JJTMETHODNAME) {
            methodType.setTables(table, methodTable);
            ASTMethodName method = (ASTMethodName) methodType;
            this.parameters = method.parameters;
            method.eval(parameters);
            this.type = method.returnType;
        } else if (methodType.id == JavammTreeConstants.JJTMAIN) {
            methodType.setTables(table, methodTable);
            methodType.eval(parser);
        } else {
            parser.semanticErrors.add(new SemanticsException("Wrong method type was found", methodType));
        }
    }

    public void processBody(Javamm parser, int stackPointer) {
        ASTMethodBody methodBody;

        if (this.jjtGetNumChildren() == 2) {
            methodBody = (ASTMethodBody) this.jjtGetChild(1);
        } else {
            methodBody = (ASTMethodBody) this.jjtGetChild(2);
        }
        methodBody.returnValue = this.type;
        methodBody.setTables(table, methodTable);
        methodBody.eval(parser, stackPointer);
    }

    @Override
    public void write(PrintWriter writer) {
        SimpleNode methodType = (SimpleNode) this.jjtGetChild(0);

        if (methodType.id == JavammTreeConstants.JJTMETHODNAME) {
            methodType.write(writer);
        } else if (methodType.id == JavammTreeConstants.JJTMAIN) {
            writer.println(".method public static main([Ljava/lang/String;)V");
        }
        writer.println("  .limit stack 255");//TODO Check for these limits actual values
        writer.println("  .limit locals 255\n");
        SimpleNode methodBody;
        if (this.jjtGetNumChildren() == 2) {
            methodBody = (ASTMethodBody) this.jjtGetChild(1);
        } else {
            methodBody = (ASTMethodBody) this.jjtGetChild(2);
        }

        methodBody.write(writer);
        writer.println(".end method");
    }

    public List<Symbol> getParameters() {
        return parameters;
    }
}
/* JavaCC - OriginalChecksum=e01bdf01dd9e8aa606ef225a59a26df3 (do not edit this line) */
