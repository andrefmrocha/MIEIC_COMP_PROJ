package javamm.parser;

import javamm.SemanticsException;
import javamm.semantics.StackUsage;
import javamm.semantics.Symbol;
import javamm.semantics.SymbolTable;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/* Generated By:JJTree: Do not edit this line. ASTMethod.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_Javamm=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTMethod extends TypeNode {
    public List<Symbol> parameters = new ArrayList<>();

    public ASTMethod(int id) {
        super(id);
    }

    public ASTMethod(Javamm p, int id) {
        super(p, id);
    }

    @Override
    public void eval(Javamm parser) {
        if (this.jjtGetNumChildren() != 2 && this.jjtGetNumChildren() != 3) {
            parser.semanticErrors.add(new SemanticsException("Lacks the number of required children!", this));
            return;
        }
        SimpleNode methodType = (SimpleNode) this.jjtGetChild(0);
        SimpleNode parameters;

        if (this.jjtGetNumChildren() == 2) {
            parameters = null;
        } else {
            parameters = (SimpleNode) this.jjtGetChild(1);
        }

        if (methodType.id == JavammTreeConstants.JJTMETHODNAME) {
            methodType.setTables(table, methodTable);
            ASTMethodName method = (ASTMethodName) methodType;
            this.parameters = method.parameters;
            method.eval(parser, parameters);
            this.type = method.returnSymbol.getType();
        } else if (methodType.id == JavammTreeConstants.JJTMAIN) {
            methodType.setTables(table, methodTable);
            methodType.eval(parser);
        } else {
            parser.semanticErrors.add(new SemanticsException("Wrong method type was found", methodType));
        }
    }

    public void processBody(Javamm parser, int stackPointer) {
        ASTMethodBody methodBody;

        if (this.jjtGetNumChildren() == 2) {
            methodBody = (ASTMethodBody) this.jjtGetChild(1);
        } else {
            methodBody = (ASTMethodBody) this.jjtGetChild(2);
        }
        int numParams = parameters.size() + 1;
        if(((SimpleNode)this.jjtGetChild(0)).id == JavammTreeConstants.JJTMAIN){
            methodBody.setTables(table.getParent(), methodTable.getParent());
        } else {
            methodBody.setTables(table, methodTable);
        }
        methodBody.returnType = this.type;
        methodBody.numParams = numParams;
        methodBody.eval(parser, stackPointer);
    }

    @Override
    public void write(PrintWriter writer) {
        SimpleNode methodType = (SimpleNode) this.jjtGetChild(0);

        if (methodType.id == JavammTreeConstants.JJTMETHODNAME) {
            methodType.write(writer);
        } else if (methodType.id == JavammTreeConstants.JJTMAIN) {
            writer.println(".method public static main([Ljava/lang/String;)V");
        }

        int paramsCount = 0;
        ASTMethodBody methodBody;
        if (this.jjtGetNumChildren() == 2) {
            methodBody = (ASTMethodBody) this.jjtGetChild(1);
        } else {
            paramsCount = ((ASTParameters) this.jjtGetChild(1)).nParams;
            methodBody = (ASTMethodBody) this.jjtGetChild(2);
        }

        if(ASTProgram.optimize) {
            int constVars = 0;
            for(int i = 0; i< methodBody.jjtGetNumChildren(); i++) {
                SimpleNode node = (SimpleNode) methodBody.jjtGetChild(i);
                if(node.id == JavammTreeConstants.JJTVAR) {
                    ASTIdentifier identifier = ((ASTIdentifier)node.jjtGetChild(1));
                    String symName = identifier.identifierName;
                    Symbol symbol = methodBody.table.getSymbol(symName);
                    if(!symbol.hasChanged() && symbol.getValue() != -1) {
                        //check if the variable can be replaced with a constant
                        constVars++;
                        methodBody.localsCount--; //therefore reducing the number of locals needed
                    } else {
                        ASTVar varNode = (ASTVar) node;
                        varNode.stackPos -= constVars;
                        symbol.setStackPos(varNode.stackPos); //move up the non constant variables in the stack
                    }
                }
            }
        }
        int localsLimit = paramsCount +
                methodBody.localsCount + 1;

        StackUsage stackUsage = new StackUsage();
        methodBody.calculateStackUsage(stackUsage);

        writer.println("  .limit stack " + stackUsage.getMaxStackUsage());
        writer.println("  .limit locals " + localsLimit + "\n");
        methodBody.write(writer);

        if (methodType.id == JavammTreeConstants.JJTMAIN || this.type == Symbol.Type.VOID) {
            writer.println("  return");
        }
        writer.println(".end method\n");
    }

    public List<Symbol> getParameters() {
        return parameters;
    }

    @Override
    public void printTable() {
        System.out.println("//".repeat(40));
        System.out.println("Method Table:");

        SimpleNode methodHeader = (SimpleNode) this.jjtGetChild(0);
        if (methodHeader.id == JavammTreeConstants.JJTMETHODNAME) {
            ASTMethodName method = (ASTMethodName) methodHeader;
            System.out.print("    Header: " + method.methodName + " | Params: <");
            for (int i = 0; i < parameters.size(); i++) {
                System.out.print(parameters.get(i).getType());
                if (i != parameters.size() - 1)
                    System.out.print(",");
                else
                    break;
            }
            System.out.println("> | Returns: " + this.type + "\n");
        } else {
            System.out.println("    Header: main | Returns: VOID\n");
        }

        if (!this.table.getTable().isEmpty()) {
            System.out.println("    Variable Table:");
            Iterator it = this.table.getTable().entrySet().iterator();
            while (it.hasNext()) {
                Map.Entry pair = (Map.Entry) it.next();
                System.out.println("      Name: " + pair.getKey() + " | Type: " + ((Symbol) pair.getValue()).getType());
            }
            System.out.println();
        }
    }
}
/* JavaCC - OriginalChecksum=e01bdf01dd9e8aa606ef225a59a26df3 (do not edit this line) */
