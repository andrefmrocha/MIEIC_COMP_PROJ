options {
    LOOKAHEAD =  1;
    MULTI = true;
}

PARSER_BEGIN(Parser)

public class Parser {

    public static void main(String[] args) throws ParseException {
            Parser parser = new Parser(System.in);
            parser.Program();
    }
}
PARSER_END(Parser)

SKIP :
{
    " " | "\t" | "\r" | "\n"
}

TOKEN:
{
    < INTEGER: (["0"-"9"])+ >
    | < LF: ";" >
    | <IMPORT: "import">
    | <CLASS: "class">
    | <EXTENDS: "extends">
    | <PUBLIC: "public">
    | <STATIC: "static">
    | <VOID: "void">
    | <MAIN: "main">
    | <STRING: "String">
    | <RETURN: "return">
    | <IF: "if">
    | <ELSE: "else">
    | <WHILE: "while">
    | <TRUE: "true">
    | <FALSE: "false">
    | <THIS: "this">
    | <NEW: "new">
    | <LENGTH: "length">
    | <INT: "int">
    | <BOOLEAN: "boolean">
    | <IDENTIFIER: ["A"-"Z", "a"-"z"](["0"-"9", "A"-"Z", "a" - "z", "_"])* >
}

SimpleNode Program() : {}
{
    ImportDeclaration() ClassDeclaration() <EOF> { return jjtThis; }
}


void ImportDeclaration() #void : {}
{
    (<IMPORT> ImportStatement() ";")*
}

void ImportStatement() #void : {}
{
    <IDENTIFIER> ("." <IDENTIFIER>)* "(" Type() ")"
}


void ClassDeclaration() #void : {}
{
    <CLASS> <IDENTIFIER>  [<EXTENDS> <IDENTIFIER> ]  "{"(VarDeclaration())* (MethodDeclaration())* "}"
}

void VarDeclaration() #void : {}
{
   Type() <IDENTIFIER> ";"
}

void MethodDeclaration() #void : {}
{
    <PUBLIC>
    (Type() <IDENTIFIER> "(" [Type() <IDENTIFIER> ("," Type() <IDENTIFIER>)*] ")" "{" ( LOOKAHEAD(2) VarDeclaration())* (Statement())* <RETURN> ComplementaryExpression() ";" "}"
    | (<STATIC> <VOID> <MAIN> "(" <STRING> "[" "]" <IDENTIFIER> ")" "{" (LOOKAHEAD(2) VarDeclaration())* (Statement())* "}")) //TODO: check if newly added production is correct

}

void Statement() #void : {}
{
    "{" (Statement())* "}"
    | <IF> "(" Expression() ")" Statement() <ELSE> Statement()
    | <WHILE> "(" Expression() ")" Statement()
    | Expression() ";"
}

void ComplementaryExpression() #void : { Token t; }
{
     ("&&" #And(2) |"<" #LessThan(2) | "+"#Sum(2) | "-"#Minus(2) | "*"#Mul(2) | "/"#Div(2) ) Expression() ComplementaryExpression()
    |"." ( <LENGTH>
    | t=<IDENTIFIER> "(" [ Expression() ("," Expression() )* ] ")" { jjtThis.methodIdentifier = t.image; }#MethodCall  ) ComplementaryExpression()
}

void Expression() #void : { Token t; }{
    t=<INTEGER>{ jjtThis.number = Integer.parseInt(t.image); } #Numeric ComplementaryExpression()
    | <TRUE> { jjtThis.number = 1; } #Numeric ComplementaryExpression()
    | <FALSE> { jjtThis.number = 0; } #Numeric ComplementaryExpression()
    | <THIS> #This ComplementaryExpression()
    | <NEW> (t= <IDENTIFIER>  { jjtThis.classIdentifier = t.image; }#New  "()" |
     <INT> "[" Expression() "]" #NewArray ) ComplementaryExpression()
    | "!" #Negation Expression() ComplementaryExpression()
    | "(" Expression() ")" ComplementaryExpression()
    | <IDENTIFIER> ("[" Expression() #ArrayAccess "]")* ["=" Expression()] ComplementaryExpression()
}

void Type() : {} //TODO: Type no longer a Token
{
      <INT>["[]"] | <BOOLEAN> | <IDENTIFIER>
}