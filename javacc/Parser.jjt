options {
    LOOKAHEAD =  1;
    MULTI = true;
}

PARSER_BEGIN(Parser)

public class Parser {

    public static void main(String[] args) throws ParseException {
            Parser parser = new Parser(System.in);
            parser.Program();
    }
}
PARSER_END(Parser)

SKIP :
{
    " " | "\t" | "\r" | "\n"
}

SKIP :
{
  < "//" (~["\r", "\n"])* >
| "/*" : ML_COMMENT_STATE
}

<ML_COMMENT_STATE> SKIP :
{
  "*/" : DEFAULT
| < ~[] >
}

TOKEN:
{
    < INTEGER: (["0"-"9"])+ >
    | <IMPORT: "import">
    | <CLASS: "class">
    | <EXTENDS: "extends">
    | <PUBLIC: "public">
    | <STATIC: "static">
    | <VOID: "void">
    | <MAIN: "main">
    | <STRING: "String">
    | <RETURN: "return">
    | <IF: "if">
    | <ELSE: "else">
    | <WHILE: "while">
    | <TRUE: "true">
    | <FALSE: "false">
    | <THIS: "this">
    | <NEW: "new">
    | <LENGTH: "length">
    | <INT: "int">
    | <BOOLEAN: "boolean">
    | <IDENTIFIER: ["A"-"Z", "a"-"z"](["0"-"9", "A"-"Z", "a" - "z", "_"])* >
    | <LFTSQRBRCKT : "[">
    | <RGHTSQRBRCKT : "]">
    | <RGHTBRCKT : ")">
    | <LFTBRCKT : "(">
    | <LFTCRLBRCKT : "{">
    | <RGHTCRLBRCKT : "}">
    | <SEMICOLON : ";">
    | <DOT : ".">
    | <COMMA : ",">
    | <EQUALS : "=">
}

SimpleNode Program() : {}
{
    ImportDeclaration() ClassDeclaration() <EOF> { return jjtThis; }
}


void ImportDeclaration() #void : {}
{
    (<IMPORT> ImportStatement() <SEMICOLON> )*
}

void ImportStatement() #void : {}
{
    <IDENTIFIER> (<DOT> <IDENTIFIER>)* <LFTBRCKT> Type() <RGHTBRCKT>
}


void ClassDeclaration() #void : {}
{
    <CLASS> <IDENTIFIER>  [<EXTENDS> <IDENTIFIER> ]  <LFTCRLBRCKT> (VarDeclaration())* (MethodDeclaration())* <RGHTCRLBRCKT>
}

void VarDeclaration() #void : {}
{
   Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() #void : {}
{
    <PUBLIC>
    (Type() <IDENTIFIER> <LFTBRCKT> [Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*] <RGHTBRCKT> <LFTCRLBRCKT> ( LOOKAHEAD(2) VarDeclaration())* (Statement())* <RETURN> Expression() <SEMICOLON> <RGHTCRLBRCKT>
    | (<STATIC> <VOID> <MAIN> <LFTBRCKT> <STRING> (<LFTSQRBRCKT> <RGHTSQRBRCKT> | "[]") <IDENTIFIER> <RGHTBRCKT> <LFTCRLBRCKT> (LOOKAHEAD(2) VarDeclaration())* (Statement())* <RGHTCRLBRCKT> )) //TODO: check if newly added production is correct

}

void Statement() #void : {Token t;}
{
    <LFTCRLBRCKT> (Statement())* <RGHTCRLBRCKT>
    | <IF>  <LFTBRCKT> Expression() #If(1) <RGHTBRCKT> Statement()  #Then(1) <ELSE> Statement()  #Else(1)
    | <WHILE> <LFTBRCKT> Expression() #While(1)  <RGHTBRCKT>  Statement() #Do(1)
    | NonIdentifierExpression() <SEMICOLON>
    | IdentifierStatement() <SEMICOLON>
}

void IdentifierStatement() #void : {Token t;}
{
    t=<IDENTIFIER> #Identifier(true)
    (
        <EQUALS> Expression() {jjtThis.varIdentifier = t.image;} #AssignVar(2)
        | <LFTSQRBRCKT> Expression() #ArrayAccess <RGHTSQRBRCKT>
            (<EQUALS> Expression() | ComplementaryExpression() ) {jjtThis.arrayIdentifier = t.image;} #AssignVarArray(2)
        | FragmentExpression()
    )
}

void ComplementaryExpression() #void :{} {
    ArrayAccessExpression()
    |
    FragmentExpression()
}

void ArrayAccessExpression() #void : {}{
    <LFTSQRBRCKT> Expression() #ArrayAccess <RGHTSQRBRCKT> ComplementaryExpression()
}

void FragmentExpression() #void : { Token t; }
{
     ("&&" Expression() #And(2)
     |"<" Expression()#LessThan(2)
     | "+"Expression()#Sum(2)
     | "-"Expression()#Minus(2)
     | "*"Expression()#Mul(2)
     | "/"Expression()#Div(2) )   ComplementaryExpression()
    |<DOT> ( <LENGTH> #Length
    | t=<IDENTIFIER> <LFTBRCKT> [ Expression() (<COMMA> Expression() )* ] <RGHTBRCKT> { jjtThis.methodIdentifier = t.image; }#MethodCall  ) ComplementaryExpression()
    | {}
}

void Expression() #void : {}{
    IdentifierExpression()
    |
    NonIdentifierExpression()
}

void NonIdentifierExpression() #void :{ Token t; }{
    t=<INTEGER>{ jjtThis.number = Integer.parseInt(t.image); } #Numeric ComplementaryExpression()
    | <TRUE> { jjtThis.number = 1; } #Numeric ComplementaryExpression()
    | <FALSE> { jjtThis.number = 0; } #Numeric ComplementaryExpression()
    | <THIS> #This ComplementaryExpression()
    | <NEW> (t= <IDENTIFIER>  { jjtThis.classIdentifier = t.image; }#New  "()" |
     <INT> <LFTSQRBRCKT> Expression() #NewArray <RGHTSQRBRCKT>  ) ComplementaryExpression()
    | "!" #Negation Expression() ComplementaryExpression()
    | <LFTBRCKT> Expression() <RGHTBRCKT> ComplementaryExpression()
}

void IdentifierExpression() #void : { Token t; }{
    t=<IDENTIFIER> { jjtThis.identifierName = t.image; } #Identifier ComplementaryExpression()
}

void Type() : {} //TODO: Type no longer a Token
{
      <INT>["[]"] | <BOOLEAN> | <IDENTIFIER>
}